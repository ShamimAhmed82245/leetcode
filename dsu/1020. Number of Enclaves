class Solution {
public:
    int parent[250009];
    int sz[250009]; 

    void make(int v){
        parent[v] = v;
        sz[v]=1;
    }

    int find(int v){
        if(v==parent[v]) return v;
        return parent[v]=find(parent[v]);//path compression
    }

    void Union(int a, int b){
        a=find(a);
        b=find(b);
        if(a!=b){
            //union by size
            if(sz[a]<sz[b]){
                swap(a,b);
            }
            parent[b]=a;
            sz[a]+=sz[b];
        }
    }

    int numEnclaves(vector<vector<int>>& grid) {
        int n=grid.size();
        int m=grid[0].size();
        int sze=n*m+6;
        for(int i=0;i<sze;i++){
            make(i);
        }
        for(int i=0;i<n;i++){
            for(int j=0;j<m;j++){
            if(grid[i][j]){
                if(i>0&&grid[i-1][j]==1) Union(i*m+j,(i-1)*m+j);
                if(j>0&&grid[i][j-1]==1) Union(i*m+j,i*m+j-1);
            }
        }
        }
        set<int>st1,st2;
        for(int i=0;i<n;i++){
            for(int j=0;j<m;j++){
            if(grid[i][j]){
               st1.insert(find(i*m+j));
            }
        }
        }
        for(int i=0;i<m;i++){
            if(grid[0][i]){
                st2.insert(find(0*m+i));
            }
        }
        for(int i=0;i<m;i++){
            if(grid[n-1][i]){
                st2.insert(find((n-1)*m+i));
            }
        }
        for(int i=0;i<n;i++){
            if(grid[i][0]){
                st2.insert(find(i*m+0));
            }
        }
        for(int i=0;i<n;i++){
            if(grid[i][m-1]){
                st2.insert(find(i*m+m-1));
            }
        }
        for(auto i:st2){
            st1.erase(i);
        }
        int ans=0;
        for(auto i:st1){
            ans+=sz[i];
        }
        return ans;
    }
};
